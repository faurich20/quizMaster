<!-- plantilla: ver_play_lobby.html (vista del anfitri√≥n) -->
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Modo Anfitri√≥n - QuizPlatform</title>
  <style>
    /* Estilos reutilizados de play.html para que luzca igual */
    * { margin:0; padding:0; box-sizing:border-box; }
    body { font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
           background: linear-gradient(135deg,#667eea 0%,#764ba2 100%);
           min-height:100vh; }
    .navbar { background: linear-gradient(135deg,#667eea 0%,#764ba2 100%);
             color:white; padding:15px 30px; display:flex; justify-content:space-between;
             align-items:center; box-shadow:0 2px 10px rgba(0,0,0,0.1); }
    .navbar h1 { font-size:1.8em; }
    .navbar-right { display:flex; align-items:center; gap:20px; }
    .btn { background: linear-gradient(135deg,#667eea 0%,#764ba2 100%);
           color:white; border:2px solid white; padding:10px 20px; border-radius:10px;
           text-decoration:none; font-weight:bold; transition:all .2s ease; }
    .btn:hover { background:white; color:#667eea; border:2px solid #667eea; }

    .page-content { display:flex; align-items:center; justify-content:center;
                    padding:20px; min-height:100vh; }
    .play-container { background:white; border-radius:20px; box-shadow:0 20px 60px rgba(0,0,0,0.3);
                     max-width:500px; width:100%; padding:40px; text-align:center; }

    .question-container { background:white; border-radius:20px; padding:30px; margin-bottom:20px; }
    .timer-bar { height:8px; background:#e0e0e0; border-radius:10px; overflow:hidden; margin-bottom:20px; }
    .timer-fill { height:100%; background: linear-gradient(90deg,#4caf50,#ffc107,#f44336); transition:width .1s linear; width:100%; }
    .question-number { color:#667eea; font-weight:bold; margin-bottom:15px; }
    .question-text { font-size:1.5em; color:#333; margin-bottom:20px; font-weight:500; }
    .question-media img { max-width:100%; border-radius:10px; margin-bottom:20px; }

    .answers-grid { display:grid; grid-template-columns:repeat(2,1fr); gap:15px; }
    .answer-btn { padding:20px; border:3px solid #e0e0e0; border-radius:15px; background:white;
                  display:flex; align-items:center; gap:15px; font-size:1em; font-weight:500;
                  transition:all .3s ease; cursor:default; user-select:none; }
    .answer-letter { width:40px; height:40px; border-radius:50%; background:#667eea; color:white;
                     display:flex; align-items:center; justify-content:center; font-weight:bold; font-size:1.2em; flex-shrink:0; }
    .answer-text { flex:1; text-align:left; }

    /* marcas visuales para correct/incorrect si queremos mostrar (no interactivo) */
    .answer-btn.correct { border-color:#4caf50; background:#4caf50; color:white; }
    .answer-btn.incorrect { border-color:#f44336; background:#f44336; color:white; }

    .results-screen { display:none; text-align:center; }
    .results-screen.active { display:block; }
    .results-header { margin-bottom:30px; }
    .score-display { background: linear-gradient(135deg,#667eea 0%,#764ba2 100%);
                     color:white; padding:30px; border-radius:15px; margin-bottom:30px; }
    .ranking-list { background:#f8f9fa; border-radius:15px; padding:20px; margin-bottom:20px; }
    .ranking-item { display:flex; justify-content:space-between; align-items:center; padding:15px;
                    background:white; border-radius:10px; margin-bottom:10px; }
    .ranking-position { width:40px; height:40px; border-radius:50%; background:#667eea; color:white;
                       display:flex; align-items:center; justify-content:center; font-weight:bold; }
    .ranking-position.first { background:#ffd700; color:#333; }
    .ranking-position.second { background:#c0c0c0; color:#333; }
    .ranking-position.third { background:#cd7f32; color:white; }

    @media (max-width:768px) {
      .answers-grid { grid-template-columns:1fr; }
    }
  </style>
</head>
<body data-session-id="{{ session_id }}">
  <div class="navbar">
    <h1>üéØ QuizPlatform</h1>
    <div class="navbar-right">
      <span>Bienvenido, <strong id="nombre_anfitrion"></strong></span>
      <a href="/dashboard" class="btn">‚Üê Volver al Dashboard</a>
      <a href="/logout" class="btn">Cerrar Sesi√≥n</a>
    </div>
  </div>

  <div class="page-content">
    <div class="play-container">
      <!-- Vista igual a play.html: pantalla de juego (solo visual) -->
      <div id="gameScreen" class="game-screen active">
        <div class="question-container">
          <div class="timer-bar"><div id="timerFill" class="timer-fill"></div></div>
          <div class="question-number" id="questionNumber">Pregunta 1 de 1</div>
          <div class="question-text" id="texto_pregunta"></div>
          <div class="question-media" id="questionMedia"></div>
        </div>

        <div class="answers-grid" id="answersGrid"></div>
      </div>

      <!-- Resultados -->
      <div id="resultsScreen" class="results-screen">
        <div class="results-header"><h2>üéâ ¬°Juego Terminado!</h2></div>
        <div class="score-display"><h3 id="finalScore">‚Äî</h3><p>Vista del Profesor</p></div>
        <div class="ranking-list">
          <h3 style="margin-bottom:15px; color:#333;">üèÜ Ranking Final</h3>
          <div id="rankingList"></div>
        </div>
        <a href="/dashboard" class="btn" style="display:inline-block; margin-top:10px;">Volver al Dashboard</a>
      </div>
    </div>
  </div>

  <script>
    // data-session-id inyectado por Flask (render_template)
    const sessionId = document.body.dataset.sessionId;
    let questions = [];
    let currentQuestion = 0;
    let timerInterval = null;
    let questionStartTimestampClient = null; // timestamp en ms cuando empez√≥ la pregunta en cliente
    let questionTimeLimit = 0;
    let pollIntervalHandle = null;
    let startedAtServer = null; // ISO string del servidor cuando la sesi√≥n comenz√≥ (si existe)

    // Mostrar nombre del profesor en navbar si corresponde (consistente con play.html)
    fetch('/api/informacion_sesion').then(r => r.json()).then(d => {
      if (d.nombre_usuario) document.getElementById('nombre_anfitrion').textContent = d.nombre_usuario;
    }).catch(()=>{});

    // 1) Carga inicial: session info -> quiz id -> preguntas
    async function loadSessionAndQuestions() {
      try {
        const res = await fetch(`/api/sesion/${sessionId}/info`);
        if (!res.ok) throw new Error('Sesi√≥n no encontrada');
        const sessionInfo = await res.json();

        if (!sessionInfo.quiz || !sessionInfo.quiz.id) {
          throw new Error('Quiz no disponible');
        }

        // Guardar started_at si existe (para sincronizar tiempo)
        startedAtServer = sessionInfo.started_at || null;

        // Cargar preguntas del quiz
        await loadQuestions(sessionInfo.quiz.id);

        // Si la sesi√≥n ya est√° iniciada, calcular en qu√© pregunta y cu√°nto tiempo restante
        // si no, esperar a que el profesor inicie (pollStatus lo detectar√°)
        const statusRes = await fetch(`/api/sesion/${sessionId}/estado`);
        const statusData = await statusRes.json();

        if (statusData && statusData.active && statusData.status === 'started') {
          // Si started_at est√° disponible en sessionInfo, usarlo para calcular la posici√≥n actual
          if (startedAtServer) {
            startFromServerTimestamp(startedAtServer);
          } else {
            // Si no hay started_at, arrancar desde 0 como fallback
            startFromIndex(0);
          }
        } else {
          // mostrar pantalla de espera estilo "lobby" pero en modo anfitri√≥n: dejamos la primera pregunta cargada pero no arrancamos temporizador
          if (questions.length > 0) {
            showQuestion(0, /*autoStartTimer=*/ false);
          }
          // iniciar polling del estado para detectar cuando el profe inicie
          pollStatus();
        }
      } catch (err) {
        console.error('Error cargando sesi√≥n/preguntas:', err);
        document.getElementById('questionText').textContent = '‚ö†Ô∏è Error cargando sesi√≥n o preguntas.';
      }
    }

    async function loadQuestions(quizId) {
      try {
        const res = await fetch(`/api/quizzes/${quizId}`);
        if (!res.ok) { questions = []; return; }
        const quiz = await res.json();
        questions = quiz.questions || [];
      } catch (e) {
        console.error('Error loadQuestions:', e);
        questions = [];
      }
    }

    // Si la sesi√≥n ya se inici√≥ antes de que el host abra la vista,
    // calcular la posici√≥n actual usando started_at del servidor.
    function startFromServerTimestamp(startedAtStr) {
      try {
        // El servidor probablemente devuelve en formato ISO o 'YYYY-MM-DD HH:MM:SS'
        // Date.parse maneja ISO; si no, reemplazamos espacio por 'T' para intentar parsear.
        let serverTs = Date.parse(startedAtStr);
        if (isNaN(serverTs)) {
          serverTs = Date.parse(startedAtStr.replace(' ', 'T'));
        }
        if (isNaN(serverTs)) {
          // fallback: iniciar desde 0
          startFromIndex(0);
          return;
        }

        const now = Date.now();
        const elapsedMs = now - serverTs; // ms desde que el profe inici√≥ la sesi√≥n
        let elapsedSec = Math.floor(elapsedMs / 1000);

        // recorrer preguntas acumulando sus time_limit para encontrar la pregunta actual
        let idx = 0;
        while (idx < questions.length && elapsedSec >= (questions[idx].time_limit || 0)) {
          elapsedSec -= (questions[idx].time_limit || 0);
          idx++;
        }

        if (idx >= questions.length) {
          // ya termin√≥ todo -> mostrar resultados
          showResults();
          return;
        }

        // Mostrar la pregunta idx y ajustar timer con elapsedSec ya usado
        showQuestion(idx, /*autoStartTimer=*/ true, /*elapsedIntoQuestion=*/ elapsedSec);
      } catch (e) {
        console.error('Error startFromServerTimestamp:', e);
        startFromIndex(0);
      }
    }

    // Iniciar desde √≠ndice y opcionalmente arrancar el timer (si autoStart true)
    // elapsedIntoQuestion (segundos) indica cu√°nto ya pas√≥ de esta pregunta (para sincronizar)
    function showQuestion(index, autoStart = true, elapsedIntoQuestion = 0) {
      if (!questions || questions.length === 0) {
        document.getElementById('questionNumber').textContent = 'Sin preguntas';
        document.getElementById('questionText').textContent = 'Este quiz no tiene preguntas.';
        document.getElementById('answersGrid').innerHTML = '';
        return;
      }

      if (index >= questions.length) {
        showResults();
        return;
      }

      // Renderizar pregunta (no interactiva)
      const q = questions[index];
      currentQuestion = index;

      document.getElementById('questionNumber').textContent = `Pregunta ${index + 1} de ${questions.length}`;
      document.getElementById('texto_pregunta').textContent = q.question_text || '';
      document.getElementById('questionMedia').innerHTML = q.image_url ? `<img src="${q.image_url}" alt="Imagen de pregunta">` : '';

      // Renderizar opciones como DIV (no onclick)
      const grid = document.getElementById('answersGrid');
      grid.innerHTML = (q.options || []).map((opt, i) => {
        // si quieres mostrar cu√°l es la correcta en anfitri√≥n al terminar, podr√≠amos marcarla, pero por ahora solo mostramos
        return `<div class="answer-btn" data-option-id="${opt.id}">
                  <div class="answer-letter">${String.fromCharCode(65 + i)}</div>
                  <div class="answer-text">${opt.option_text}</div>
                </div>`;
      }).join('');

      // Si autoStart es true -> iniciar temporizador teniendo en cuenta elapsedIntoQuestion
      // elapsedIntoQuestion: segundos ya consumidos en esta pregunta
      if (autoStart) {
        const timeLimit = parseInt(q.time_limit || 30, 10);
        const remaining = Math.max(0, timeLimit - (elapsedIntoQuestion || 0));
        startTimer(remaining, timeLimit);
      } else {
        // mostrar barra llena a 100% (sin iniciar)
        const fill = document.getElementById('timerFill');
        fill.style.width = '100%';
        // actualizar n√∫mero de pregunta aunque sin timer
      }
    }

    // startTimer(remainingSeconds, originalQuestionLimit)
    // remainingSeconds = seconds to count down for this display (might be less when joining late)
    function startTimer(remainingSeconds, originalLimitForVisual) {
      // clear previo
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }

      // guardar datos
      questionTimeLimit = originalLimitForVisual || remainingSeconds;
      questionStartTimestampClient = Date.now();

      const fill = document.getElementById('timerFill');
      // Protecci√≥n: si remainingSeconds <= 0 -> ir a siguiente pregunta inmediatamente
      if (remainingSeconds <= 0) {
        // avanzar a siguiente (mantenemos un peque√±o delay visual)
        setTimeout(() => {
          showQuestion(currentQuestion + 1, true, 0);
        }, 300);
        return;
      }

      let timeLeft = remainingSeconds;
      fill.style.width = `${(timeLeft / (originalLimitForVisual || remainingSeconds)) * 100}%`;

      timerInterval = setInterval(() => {
        timeLeft--;
        // evitar divisi√≥n por cero
        const denom = (originalLimitForVisual && originalLimitForVisual > 0) ? originalLimitForVisual : Math.max(1, remainingSeconds);
        fill.style.width = `${Math.max(0, (timeLeft / denom) * 100)}%`;

        if (timeLeft <= 0) {
          clearInterval(timerInterval);
          timerInterval = null;
          // esperar 800ms para transici√≥n visual como en play.html
          setTimeout(() => {
            showQuestion(currentQuestion + 1, true, 0);
          }, 800);
        }
      }, 1000);
    }

    // Polling del estado de sesi√≥n para detectar cuando el profesor la inicia o la finaliza
    async function pollStatus() {
      try {
        const res = await fetch(`/api/sesion/${sessionId}/estado`);
        if (!res.ok) {
          // si 404 u otro, paramos polling
          console.error('check_status no ok', res.status);
          return;
        }
        const s = await res.json();

        if (!s.active || s.status === 'finished') {
          // finalizar vista de anfitri√≥n y ver ranking
          if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
          await loadResultsAndShow();
          return;
        }

        if (s.status === 'started') {
          // Si la sesi√≥n est√° started pero nuestro temporizador no corre (o estamos en pantalla previa), sincronizar:
          // Preferimos usar started_at desde /api/session/<id>/info porque check_status no incluye started_at.
          // Obtener info completa solo la primera vez o si no tenemos startedAt.
          if (!startedAtServer) {
            const infoRes = await fetch(`/api/sesion/${sessionId}/info`);
            if (infoRes.ok) {
              const infoData = await infoRes.json();
              startedAtServer = infoData.started_at || null;
              if (startedAtServer) {
                startFromServerTimestamp(startedAtServer);
                // luego seguir polling
              } else {
                // fallback: si no hay started_at, empezar desde 0 si no estamos ya jugando
                if (!timerInterval) startFromIndex(0);
              }
            } else {
              // fallback
              if (!timerInterval) startFromIndex(0);
            }
          }
        }
      } catch (err) {
        console.error('Error pollStatus:', err);
      } finally {
        // re-agendar polling
        if (!pollIntervalHandle) {
          pollIntervalHandle = setTimeout(pollStatus, 2000);
        } else {
          // si ya programado con setTimeout, no hacemos nada; si no, volvemos a programar
        }
      }
    }

    // Helper que inicia desde √≠ndice 0 (o el √≠ndice indicado)
    function startFromIndex(idx) {
      if (!questions || questions.length === 0) {
        return;
      }
      showQuestion(idx, true, 0);
    }

    // Cargar y mostrar resultados (igual que en play.html)
    async function loadResultsAndShow() {
      try {
        // detener polling
        if (pollIntervalHandle) { clearTimeout(pollIntervalHandle); pollIntervalHandle = null; }
        if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }

        // ocultar pantalla de juego
        const gs = document.getElementById('gameScreen');
        if (gs) gs.style.display = 'none';

        // mostrar pantalla de resultados
        const rs = document.getElementById('resultsScreen');
        if (rs) rs.classList.add('active');

        // obtener ranking
        const res = await fetch(`/api/resultados/${sessionId}`);
        if (!res.ok) {
          throw new Error('Error al obtener resultados');
        }
        const ranking = await res.json();

        // pintar ranking
        const listEl = document.getElementById('rankingList');
        listEl.innerHTML = ranking.map((p, idx) => {
          const cls = idx === 0 ? 'first' : idx === 1 ? 'second' : idx === 2 ? 'third' : '';
          const medal = idx === 0 ? 'ü•á' : idx === 1 ? 'ü•à' : idx === 2 ? 'ü•â' : (idx + 1);
          return `<div class="ranking-item">
                    <div class="ranking-position ${cls}">${medal}</div>
                    <div class="ranking-name">${p.username}</div>
                    <div class="ranking-score">${p.total_score} pts</div>
                  </div>`;
        }).join('');

      } catch (err) {
        console.error('Error loading results:', err);
        document.getElementById('rankingList').innerHTML = '<p>Error al cargar resultados.</p>';
      }
    }

    // seguridad al cerrar pesta√±a: limpiar intervals
    window.addEventListener('beforeunload', () => {
      if (timerInterval) clearInterval(timerInterval);
      if (pollIntervalHandle) clearTimeout(pollIntervalHandle);
    });

    // Iniciar todo
    loadSessionAndQuestions();
    // iniciar polling de estado (para detectar inicio/fin)
    pollStatus();
  </script>
  <script>
window.apiES = window.apiES || {};
window.apiES.sessionInfo = () => fetch('/api/informacion_sesion').then(r=>r.json());
window.apiES.obtenerInfoSesion = (id) => fetch(`/api/sesion/${id}/info`).then(r=>r.json());
window.apiES.obtenerResultados = (id) => fetch(`/api/resultados/${id}`).then(r=>r.json());
</script>
</body>
</html>
